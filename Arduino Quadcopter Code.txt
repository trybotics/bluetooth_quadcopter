#include <Wire.h>
#include "MPUSensor.h"
#include <Servo.h>
#include "PID_v1.h"

#define ESC_A 4 
#define ESC_B 3
#define ESC_C 6
#define ESC_D 5
#define ESC_MIN 30
#define ESC_MAX 170

#define PITCH_P 0.201f
#define PITCH_I 0.040f
#define PITCH_D 0.108f 
#define PITCH_MAX_MOTOR_BALANCE_SPEED 25                 // max amount of thrust that will be applied to balance this axis
#define PITCH_PID_OUTPUT 20
#define PITCH_ERROR_CORRECTION 0

#define ROLL_P 0.201f
#define ROLL_I 0.040f
#define ROLL_D 0.108f
#define ROLL_MAX_MOTOR_BALANCE_SPEED 20                  // max amount of thrust that will be applied to balance this axis
#define ROLL_PID_OUTPUT 20
#define ROLL_ERROR_CORRECTION 0

#define YAW_P 0.3f
#define YAW_I 0.0f
#define YAW_D 0.06f
#define YAW_PID_OUTPUT 1
#define YAW_MAX_MOTOR_BALANCE_SPEED 1                   // max amount of thrust that will be applied to balance this axis
#define YAW_ERROR_CORRECTION 0.0248f 

#define MAX_YAW_SPEED 90                                 // degrees of rotation per second when controlled with RC controler
#define MAX_ROLL_ANGLE 30
#define MAX_PITCH_ANGLE 30

#define HOVER_MOTOR_SPEED 10

#define ESC_ARM_TIME 5000                                // in milliseconds, this requires so much time because I also need to wait for sensor values to normalize.
#define SENSOR_NORMALIZE_TIME 1000*20

#define SERIAL_UPDATE_TIME 0.01f

double pitchSp, rollSp, yawSp = 0;                       // setpoints
bool yawSpSet = false;
double P,I,D;                                            // PID values 
float velocity;                                          // global velocity
double bal_ac = 0, bal_bd, bal_axes = 0;                 // motor balances can vary between -100 & 100, motor balance between axes -100:ac , +100:bd
float deltaTime = 0;

double va, vb, vc, vd, v_ac, v_bd = 0;                   // velocities
double pitch, roll, yaw  = 0.0;                          // angles in degrees

Servo a,b,c,d;                                           // motors

PID pitchReg(&pitch, &bal_bd, &pitchSp, PITCH_P, PITCH_I, PITCH_D, DIRECT);
PID rollReg(&roll, &bal_ac, &rollSp, ROLL_P, ROLL_I, ROLL_D, DIRECT);
PID yawReg(&yaw, &bal_axes, &yawSp, YAW_P, YAW_I, YAW_D, DIRECT);

float sentTime = 0;

int data=0,spd=0,x=0;
char c1;

MPUSensor sensor;

void setup(){
  Serial1.begin(9600);
  pinMode(A1,OUTPUT);
  pinMode(A2,OUTPUT);
  pinMode(A3,OUTPUT);

  digitalWrite(A1,LOW);
  digitalWrite(A2,LOW);
  digitalWrite(A3,LOW);
  sensor.init();

  initPIDs();
  initESCs();
  armESCs();

}

void loop(){ 
  long start = micros();
  computeRotation();
  computeVelocities();

  if(yaw != 180 & yaw != 0 && yawSpSet == false){
    yawSp = yaw;
    yawSpSet = true; 
  }
  bluetooth(); 
  updateMotors();

  if(sensor.isReady())
    sensor.calculate();
}

void bluetooth()
{
  if (Serial1.available() > 0)
  {
  data = Serial1.read();
  c1=(char)data;
  if(data<=50)
   spd=data;
  }
  velocity = map(spd,0,25, ESC_MIN, ESC_MAX);
}
void computeRotation()
{
  pitch = ((sensor.getPitch()+PITCH_ERROR_CORRECTION)*(180/M_PI)); // Get value from sensor, correct it, and convert from radians to degrees
  roll = ((sensor.getRoll()+ROLL_ERROR_CORRECTION)*(180/M_PI));    // Same thing here
  yaw = ((sensor.getYaw()+ROLL_ERROR_CORRECTION)*(180/M_PI));
  //if(abs(pitch) <= 1.5f) pitch = 0;
  //if(abs(roll) <= 1.5f) roll = 0;
}

void computeVelocities()
{
  if(pitchReg.Compute()){
    bal_bd /= PITCH_PID_OUTPUT;
    vd = velocity+(bal_bd*PITCH_MAX_MOTOR_BALANCE_SPEED);
    vb = velocity-(bal_bd*PITCH_MAX_MOTOR_BALANCE_SPEED);
  }

  if(rollReg.Compute()){
    bal_ac /= ROLL_PID_OUTPUT;
    va = velocity+(bal_ac*ROLL_MAX_MOTOR_BALANCE_SPEED);
    vc = velocity-(bal_ac*ROLL_MAX_MOTOR_BALANCE_SPEED);
  }

  if(yawReg.Compute()){
    bal_axes /= YAW_PID_OUTPUT;
    va -= bal_axes*YAW_MAX_MOTOR_BALANCE_SPEED;
    vc -= bal_axes*YAW_MAX_MOTOR_BALANCE_SPEED;

    vb += bal_axes*YAW_MAX_MOTOR_BALANCE_SPEED;
    vd += bal_axes*YAW_MAX_MOTOR_BALANCE_SPEED;
  }
}

void updateMotors(){
  a.write(va);
  c.write(vc);
  b.write(vb);
  d.write(vd);
}

void initESCs(){
  // attach ESCs to servos
  a.attach(ESC_A);
  b.attach(ESC_B);
  c.attach(ESC_C);
  d.attach(ESC_D);
}

void armESCs(){
  va = vb = vc = vd = ESC_MIN;
  updateMotors();
  delay(ESC_ARM_TIME);
}

void initPIDs(){
  pitchReg.SetMode(AUTOMATIC);
  pitchReg.SetOutputLimits(-PITCH_PID_OUTPUT, PITCH_PID_OUTPUT);
  pitchReg.SetSampleTime(14);

  rollReg.SetMode(AUTOMATIC);
  rollReg.SetOutputLimits(-ROLL_PID_OUTPUT, ROLL_PID_OUTPUT);
  rollReg.SetSampleTime(14);

  yawReg.SetMode(AUTOMATIC);
  yawReg.SetOutputLimits(-YAW_PID_OUTPUT, YAW_PID_OUTPUT);
  yawReg.SetSampleTime(14);
}





